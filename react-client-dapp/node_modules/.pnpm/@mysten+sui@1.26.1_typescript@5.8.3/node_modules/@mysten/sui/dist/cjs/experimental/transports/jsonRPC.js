"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var jsonRPC_exports = {};
__export(jsonRPC_exports, {
  JSONRpcTransport: () => JSONRpcTransport
});
module.exports = __toCommonJS(jsonRPC_exports);
var import_bcs = require("@mysten/bcs");
var import_bcs2 = require("../../bcs/index.js");
var import_utils = require("../../transactions/plugins/utils.js");
var import_Transaction = require("../../transactions/Transaction.js");
var import_core = require("../core.js");
var import_errors = require("../errors.js");
var _jsonRpcClient;
class JSONRpcTransport extends import_core.Experimental_CoreClient {
  constructor(jsonRpcClient) {
    super({ network: jsonRpcClient.network });
    __privateAdd(this, _jsonRpcClient);
    __privateSet(this, _jsonRpcClient, jsonRpcClient);
  }
  async getObjects(options) {
    const batches = (0, import_utils.batch)(options.objectIds, 50);
    const results = [];
    for (const batch2 of batches) {
      const objects = await __privateGet(this, _jsonRpcClient).multiGetObjects({
        ids: batch2,
        options: {
          showOwner: true,
          showType: true
        }
      });
      for (const [idx, object] of objects.entries()) {
        if (object.error) {
          results.push(import_errors.ObjectError.fromResponse(object.error, batch2[idx]));
        } else {
          results.push(parseObject(object.data));
        }
      }
    }
    return {
      objects: results
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateGet(this, _jsonRpcClient).getOwnedObjects({
      owner: options.address,
      limit: options.limit,
      cursor: options.cursor
    });
    return {
      objects: objects.data.map((result) => {
        if (result.error) {
          throw import_errors.ObjectError.fromResponse(result.error);
        }
        return parseObject(result.data);
      }),
      hasNextPage: objects.hasNextPage,
      cursor: objects.nextCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateGet(this, _jsonRpcClient).getCoins({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      objects: coins.data.map((coin) => {
        return {
          id: coin.coinObjectId,
          version: coin.version,
          digest: coin.digest,
          balance: BigInt(coin.balance),
          type: `0x2::coin::Coin<${coin.coinType}>`,
          content: Coin.serialize({
            id: coin.coinObjectId,
            balance: {
              value: coin.balance
            }
          }).toBytes(),
          owner: {
            $kind: "ObjectOwner",
            ObjectOwner: options.address
          }
        };
      }),
      hasNextPage: coins.hasNextPage,
      cursor: coins.nextCursor ?? null
    };
  }
  async getBalance(options) {
    const balance = await __privateGet(this, _jsonRpcClient).getBalance({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      balance: {
        coinType: balance.coinType,
        balance: BigInt(balance.totalBalance)
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateGet(this, _jsonRpcClient).getAllBalances({
      owner: options.address
    });
    return {
      balances: balances.map((balance) => ({
        coinType: balance.coinType,
        balance: BigInt(balance.totalBalance)
      })),
      hasNextPage: false,
      cursor: null
    };
  }
  async getTransaction(options) {
    const transaction = await __privateGet(this, _jsonRpcClient).getTransactionBlock({
      digest: options.digest,
      options: {
        showRawInput: true,
        showObjectChanges: true,
        showRawEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async executeTransaction(options) {
    const transaction = await __privateGet(this, _jsonRpcClient).executeTransactionBlock({
      transactionBlock: options.transaction,
      signature: options.signatures,
      options: {
        showEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async dryRunTransaction(options) {
    const tx = import_Transaction.Transaction.from(options.transaction);
    const result = await __privateGet(this, _jsonRpcClient).dryRunTransactionBlock({
      transactionBlock: options.transaction
    });
    return {
      transaction: {
        digest: await tx.getDigest(),
        // TODO: Effects aren't returned as bcs from dryRun, once we define structured effects we can return those instead
        effects: result.effects,
        signatures: [],
        bcs: options.transaction
      }
    };
  }
  async getReferenceGasPrice() {
    const referenceGasPrice = await __privateGet(this, _jsonRpcClient).getReferenceGasPrice();
    return {
      referenceGasPrice
    };
  }
}
_jsonRpcClient = new WeakMap();
function parseObject(object) {
  return {
    id: object.objectId,
    version: object.version,
    digest: object.digest,
    type: object.type,
    content: object.bcs?.dataType === "moveObject" ? (0, import_bcs.fromBase64)(object.bcs.bcsBytes) : new Uint8Array(),
    owner: parseOwner(object.owner)
  };
}
function parseOwner(owner) {
  if (owner === "Immutable") {
    return {
      $kind: "Immutable",
      Immutable: true
    };
  }
  if ("ConsensusV2" in owner) {
    return {
      $kind: "ConsensusV2",
      ConsensusV2Owner: {
        authenticator: {
          $kind: "SingleOwner",
          SingleOwner: owner.ConsensusV2.authenticator.SingleOwner
        },
        startVersion: owner.ConsensusV2.start_version
      }
    };
  }
  if ("AddressOwner" in owner) {
    return {
      $kind: "AddressOwner",
      AddressOwner: owner.AddressOwner
    };
  }
  if ("ObjectOwner" in owner) {
    return {
      $kind: "ObjectOwner",
      ObjectOwner: owner.ObjectOwner
    };
  }
  if ("Shared" in owner) {
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: owner.Shared.initial_shared_version
      }
    };
  }
  throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseTransaction(transaction) {
  const parsedTx = import_bcs2.bcs.SenderSignedData.parse((0, import_bcs.fromBase64)(transaction.rawTransaction))[0];
  return {
    digest: transaction.digest,
    effects: new Uint8Array(transaction.rawEffects),
    bcs: import_bcs2.bcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes(),
    signatures: parsedTx.txSignatures
  };
}
const Balance = import_bcs2.bcs.struct("Balance", {
  value: import_bcs2.bcs.u64()
});
const Coin = import_bcs2.bcs.struct("Coin", {
  id: import_bcs2.bcs.Address,
  balance: Balance
});
//# sourceMappingURL=jsonRPC.js.map
