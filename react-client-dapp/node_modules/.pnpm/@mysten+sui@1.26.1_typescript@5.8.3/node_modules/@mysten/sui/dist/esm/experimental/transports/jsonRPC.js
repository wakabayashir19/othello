var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _jsonRpcClient;
import { fromBase64 } from "@mysten/bcs";
import { bcs } from "../../bcs/index.js";
import { batch } from "../../transactions/plugins/utils.js";
import { Transaction } from "../../transactions/Transaction.js";
import { Experimental_CoreClient } from "../core.js";
import { ObjectError } from "../errors.js";
class JSONRpcTransport extends Experimental_CoreClient {
  constructor(jsonRpcClient) {
    super({ network: jsonRpcClient.network });
    __privateAdd(this, _jsonRpcClient);
    __privateSet(this, _jsonRpcClient, jsonRpcClient);
  }
  async getObjects(options) {
    const batches = batch(options.objectIds, 50);
    const results = [];
    for (const batch2 of batches) {
      const objects = await __privateGet(this, _jsonRpcClient).multiGetObjects({
        ids: batch2,
        options: {
          showOwner: true,
          showType: true
        }
      });
      for (const [idx, object] of objects.entries()) {
        if (object.error) {
          results.push(ObjectError.fromResponse(object.error, batch2[idx]));
        } else {
          results.push(parseObject(object.data));
        }
      }
    }
    return {
      objects: results
    };
  }
  async getOwnedObjects(options) {
    const objects = await __privateGet(this, _jsonRpcClient).getOwnedObjects({
      owner: options.address,
      limit: options.limit,
      cursor: options.cursor
    });
    return {
      objects: objects.data.map((result) => {
        if (result.error) {
          throw ObjectError.fromResponse(result.error);
        }
        return parseObject(result.data);
      }),
      hasNextPage: objects.hasNextPage,
      cursor: objects.nextCursor ?? null
    };
  }
  async getCoins(options) {
    const coins = await __privateGet(this, _jsonRpcClient).getCoins({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      objects: coins.data.map((coin) => {
        return {
          id: coin.coinObjectId,
          version: coin.version,
          digest: coin.digest,
          balance: BigInt(coin.balance),
          type: `0x2::coin::Coin<${coin.coinType}>`,
          content: Coin.serialize({
            id: coin.coinObjectId,
            balance: {
              value: coin.balance
            }
          }).toBytes(),
          owner: {
            $kind: "ObjectOwner",
            ObjectOwner: options.address
          }
        };
      }),
      hasNextPage: coins.hasNextPage,
      cursor: coins.nextCursor ?? null
    };
  }
  async getBalance(options) {
    const balance = await __privateGet(this, _jsonRpcClient).getBalance({
      owner: options.address,
      coinType: options.coinType
    });
    return {
      balance: {
        coinType: balance.coinType,
        balance: BigInt(balance.totalBalance)
      }
    };
  }
  async getAllBalances(options) {
    const balances = await __privateGet(this, _jsonRpcClient).getAllBalances({
      owner: options.address
    });
    return {
      balances: balances.map((balance) => ({
        coinType: balance.coinType,
        balance: BigInt(balance.totalBalance)
      })),
      hasNextPage: false,
      cursor: null
    };
  }
  async getTransaction(options) {
    const transaction = await __privateGet(this, _jsonRpcClient).getTransactionBlock({
      digest: options.digest,
      options: {
        showRawInput: true,
        showObjectChanges: true,
        showRawEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async executeTransaction(options) {
    const transaction = await __privateGet(this, _jsonRpcClient).executeTransactionBlock({
      transactionBlock: options.transaction,
      signature: options.signatures,
      options: {
        showEffects: true,
        showEvents: true
      }
    });
    return {
      transaction: parseTransaction(transaction)
    };
  }
  async dryRunTransaction(options) {
    const tx = Transaction.from(options.transaction);
    const result = await __privateGet(this, _jsonRpcClient).dryRunTransactionBlock({
      transactionBlock: options.transaction
    });
    return {
      transaction: {
        digest: await tx.getDigest(),
        // TODO: Effects aren't returned as bcs from dryRun, once we define structured effects we can return those instead
        effects: result.effects,
        signatures: [],
        bcs: options.transaction
      }
    };
  }
  async getReferenceGasPrice() {
    const referenceGasPrice = await __privateGet(this, _jsonRpcClient).getReferenceGasPrice();
    return {
      referenceGasPrice
    };
  }
}
_jsonRpcClient = new WeakMap();
function parseObject(object) {
  return {
    id: object.objectId,
    version: object.version,
    digest: object.digest,
    type: object.type,
    content: object.bcs?.dataType === "moveObject" ? fromBase64(object.bcs.bcsBytes) : new Uint8Array(),
    owner: parseOwner(object.owner)
  };
}
function parseOwner(owner) {
  if (owner === "Immutable") {
    return {
      $kind: "Immutable",
      Immutable: true
    };
  }
  if ("ConsensusV2" in owner) {
    return {
      $kind: "ConsensusV2",
      ConsensusV2Owner: {
        authenticator: {
          $kind: "SingleOwner",
          SingleOwner: owner.ConsensusV2.authenticator.SingleOwner
        },
        startVersion: owner.ConsensusV2.start_version
      }
    };
  }
  if ("AddressOwner" in owner) {
    return {
      $kind: "AddressOwner",
      AddressOwner: owner.AddressOwner
    };
  }
  if ("ObjectOwner" in owner) {
    return {
      $kind: "ObjectOwner",
      ObjectOwner: owner.ObjectOwner
    };
  }
  if ("Shared" in owner) {
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: owner.Shared.initial_shared_version
      }
    };
  }
  throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);
}
function parseTransaction(transaction) {
  const parsedTx = bcs.SenderSignedData.parse(fromBase64(transaction.rawTransaction))[0];
  return {
    digest: transaction.digest,
    effects: new Uint8Array(transaction.rawEffects),
    bcs: bcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes(),
    signatures: parsedTx.txSignatures
  };
}
const Balance = bcs.struct("Balance", {
  value: bcs.u64()
});
const Coin = bcs.struct("Coin", {
  id: bcs.Address,
  balance: Balance
});
export {
  JSONRpcTransport
};
//# sourceMappingURL=jsonRPC.js.map
